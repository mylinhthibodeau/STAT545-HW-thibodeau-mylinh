---
title: "stat545-hw04-thibodeau-mylinh"
author: "My Linh Thibodeau"
date: '2017-10-07'
output: github_document
---

```{r}
suppressPackageStartupMessages(library(tidyverse))
knitr::opts_chunk$set(fig.width=12, fig.height=9)
library(knitr)
library(kableExtra)
options(knitr.table.format = "html")
library(reshape2)
#install.packages("tidygenomics") # Not used for now, but perhaps in another homework
#library(tidygenomics) # Not used for now, but perhaps in another homework
```

# Genomic datasets - A few clarifications

Vincenzo Coia has approved my request to use published genomic data for the next assignments, therefore, I want to provide a few clarifications:

* I have tried to introduce some basic explanations about the genomic dataset, but as my objective is to explore and learn how to use R and its packages, not to teach cancer genomic analysis, I am sorry in advance if you are not sure what the data and plots represent, but focus on the data manipulation behind and not what the data represents, and I hope you will still enjoy reading my homework !
* If you have any questions, please don't hesitate to let me know :) 
* Given the size of the data, I only display a few rows per table to keep it readable.
* If you are not sure of the corresponding variables (or equivalences) between gapminder and my genomic datasets, you can always go back to the README.md file [here](https://github.com/mylinhthibodeau/STAT545-HW-thibodeau-mylinh/tree/master/stat545-hw4-thibodeau-mylinh)
* RPKM (Reads Per Kilobase of transcript per Million mapped reads) is a measure of gene expression obtained from RNAseq data.

## SOURCES OF DATA: The Cancer Genome Atlas (TCGA) and ClinVar 

After trying to complete this homework with the genomic data previously used in [homework 3](https://github.com/mylinhthibodeau/STAT545-HW-thibodeau-mylinh/tree/master/stat545-hw3-thibodeau-mylinh), I realized that it was impossible for me to do some of the exercises because I didn't have the right "data.frame" format for it. 

**The Cancer Genome Atlas (TCGA)**    
The results shown here are in whole or part based upon data generated by the TCGA Research Network: http://cancergenome.nih.gov/

Genomic datasets are available through the cBioportal [here](http://www.cbioportal.org/data_sets.jsp)

**ClinVar**  
The results shown here are in whole or part based upon the data generated by the NCBI ClinVar data portal: https://www.ncbi.nlm.nih.gov/clinvar/

The ClinVar genomic variant dataset is publicly available [here](ftp://ftp.ncbi.nlm.nih.gov/pub/clinvar/tab_delimited/). If you would like more information on the type of files available, please read this [primer](https://www.ncbi.nlm.nih.gov/clinvar/docs/ftp_primer/) on the topic.

# Setting up the data

## Getting the data ready

Let's select some RNAseq (gene expression) cancers datasets from TCGA:

* brca: breast cancer
* gbm: glioblastoma
* pcpg: pheochromocytome-paraganglioma
* sarc: sarcoma
* skcm: skin cutaneous melanoma
* coadread: colorectal adenocarcinoma
* dlbc: diffuse large B-cell lymphoma

I will only select 100 genes (nrows = 100) for each dataset, because there are way to many genes (18000-20000) to keep them all, and also, we will only select 3 samples per cancer type ([ ,c(1,3,4,5)]):
```{r}
brca_rna <- read.table("/Users/mylinh/Documents/published_data/tcga/brca/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[ ,c(1,3,4,5)]
colnames(brca_rna) <- c("hugo", "brca.s1", "brca.s2", "brca.s3")
brca_rna <- brca_rna[!duplicated(brca_rna$hugo), ]
brca_rna$cancer.type <- "BRCA"
#View(brca_rna)

gbm_rna <- read.table("/Users/mylinh/Documents/published_data/tcga/gbm/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[, c(1,3,4,5)]
colnames(gbm_rna) <- c("hugo", "gbm.s1", "gbm.s2", "gbm.s3")
gbm_rna <- gbm_rna[!duplicated(gbm_rna$hugo), ]
gbm_rna$cancer.type <- "GBM"
#View(gbm_rna)

pcpg_rna <- read.table("/Users/mylinh/Documents/published_data/tcga/pcpg/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[, c(1,3,4,5)]
colnames(pcpg_rna) <- c("hugo", "pcpg.s1", "pcpg.s2", "pcpg.s3")
pcpg_rna <- pcpg_rna[!duplicated(pcpg_rna$hugo), ]
pcpg_rna$cancer.type <- "PCPG"
#View(pcpg_rna)

sarc_rna <- read.table("/Users/mylinh/Documents/published_data/tcga/sarc/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[, c(1,3,4,5)]
colnames(sarc_rna) <- c("hugo", "sarc.s1", "sarc.s2", "sarc.s3")
sarc_rna <- sarc_rna[!duplicated(sarc_rna$hugo), ]
sarc_rna$cancer.type <- "SARC"
#View(sarc_rna)

skcm_rna <- read.table("/Users/mylinh/Documents/published_data/tcga/skcm/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[, c(1,3,4,5)]
colnames(skcm_rna) <- c("hugo", "skcm.s1", "skcm.s2", "skcm.s3")
skcm_rna <- skcm_rna[!duplicated(skcm_rna$hugo), ]
skcm_rna$cancer.type <- "SKCM"
#View(skcm_rna)

coadread_rna <- read.table("/Users/mylinh/Documents/published_data/tcga/coadread/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[, c(1,3,4,5)]
colnames(coadread_rna) <- c("hugo", "coadread.s1", "coadread.s2", "coadread.s3")
coadread_rna <- coadread_rna[!duplicated(coadread_rna$hugo), ]
coadread_rna$cancer.type <- "COADREAD"
#View(coadread_rna)

dlbc_rna <- read.table("/Users/mylinh/Documents/published_data/tcga/dlbc/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[, c(1,3,4,5)]
colnames(dlbc_rna) <- c("hugo", "dlbc.s1", "dlbc.s2", "dlbc.s3")
dlbc_rna <- dlbc_rna[!duplicated(dlbc_rna$hugo), ]
dlbc_rna$cancer.type <- "DLBC"
#View(dlbc_rna)
```
**Note1.** I populated one additional column per dataset with the cancer.type as this will represent my "gapminder$continent" value later on. I tried the technique explained on [computer world here](https://www.computerworld.com/article/2486415/business-intelligence/business-intelligence-4-data-wrangling-tasks-in-r-for-advanced-beginners.html), and although it didn't work out, it gave me the idea of creating a new column "cancer.type" with a single value for the specific cancer.
**Note2.** I found a way of selecting specific columns in read.table with [this stackoverflow dicussion](https://stackoverflow.com/questions/5788117/only-read-limited-number-of-columns) and [this stackexchange discussion](https://stats.stackexchange.com/questions/16796/reading-only-two-out-of-three-columns-with-read-csv).
Note3. After experiencing issues later on in this homework, I had to remove the hugo genes that had 2 or more values for the same cancer sample. I needed to have only one gene-sample key for the spread() function to workout. I found the information about how to remove duplicate [here](https://stackoverflow.com/questions/13279582/select-only-the-first-rows-for-each-unique-value-of-a-column-in-r)

# General data reshaping and relationship to aggregation

## Activity #1 - Make your own cheetsheet

**Make you own cheatsheet similar to Tyler Rinkerâ€™s [minimal guide to tidyr](https://github.com/trinker/tidyr_in_a_nutshell).**

I also like this [Data Wrangling with dplyr and tidyr cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf).

I found a few tutorials that I liked as well:

* University of Virginia: [A tidyr Tutorial](http://data.library.virginia.edu/a-tidyr-tutorial/)
* RPubs of RStudio: [Data Processing with dplyr & tidyr](https://rpubs.com/bradleyboehmke/data_wrangling) by Brad Boehmke
* Tidyverse website: [tidyr article](http://tidyr.tidyverse.org/)

### GATHER: From horizontal (wide) to vertical (longer)

According the the Help of RStudio, the gather() function is a way to take columns that are not variables and collapse multiple columns to key-value pairs. 

For my type of data, I think gather() will be useful when I realize that a group of columns actually represent the same variable and therefore, they should be "stacked on top of each other" () rather than in adjacent columns. As Hadley Wickham said in his [Introducing tidyr blog](https://blog.rstudio.com/2014/07/22/introducing-tidyr/),the most important for tidy data is that each column is a variable and each row is an observation.

Let's take a look at the brca_rna data:
```{r}
brca_rna %>%
  head(10) %>%
  kable("html") %>% kable_styling()
```

The TCGA RNAseq datasets are perfect for this exercise, because the columns in each dataset represent a different sample, and therefore, they are actually different obversations. I will start by making new "gathered" data.frame.
```{r}
brca_rna_gather <- brca_rna %>%
  gather(key = sample, value = RPKM, brca.s1, brca.s2, brca.s3)
#View(brca_rna_gather)
gbm_rna_gather <- gbm_rna %>%
  gather(key=sample, value = RPKM, gbm.s1, gbm.s2, gbm.s3)
pcpg_rna_gather <- pcpg_rna %>%
  gather(key = sample, value = RPKM, pcpg.s1, pcpg.s2, pcpg.s3)
sarc_rna_gather <- sarc_rna %>%
  gather(key=sample, value = RPKM, sarc.s1, sarc.s2, sarc.s3)
skcm_rna_gather <- skcm_rna %>%
  gather(key = sample, value = RPKM, skcm.s1, skcm.s2, skcm.s3)
coadread_rna_gather <- coadread_rna %>%
  gather(key = sample, value = RPKM, coadread.s1, coadread.s2, coadread.s3)
dlbc_rna_gather <- dlbc_rna %>%
  gather(key =sample, value = RPKM, dlbc.s1, dlbc.s2, dlbc.s3)
```

And now, if we take the same brca data, but the after using the gather() function:
```{r}
brca_rna_gather %>%
  head(10) %>%
  kable("html") %>% kable_styling()
```

### SPREAD: From vertical (longer) to horizontal (wide)  

In order to revert back to the original format of the data, I can use the same key:value pairing in the spread() function. For example, the following code's output is the original data format since gather() and spread() are mirror functions from each other.

```{r}
brca_rna %>%
  gather(key = sample, value = RPKM, brca.s1, brca.s2, brca.s3) %>%
  spread(key=sample, value=RPKM) %>%
  head(10) %>%
  kable("html") %>% kable_styling()
```

* *Initially, I had an error message: "Error: Duplicate identifiers for rows (2, 3), (52, 53), (102, 103)". It turns out that the spread() function does not like the fact that some gene names are duplicated for the sample (because of non-unique identifiers, it is unable to match back the columns after gather). When I didn't know better, I applied some extra functions to filter the gene duplicates (e.g. brca_rna <- brca_rna[!duplicated(brca_rna$hugo), ]).*

* *I have learned in the cm011 class as way to circumvene that problem by using dcast (from Reshape2) instead of spread (from Tidyr). I can tell dcast() how to deal with duplicated identifiers (genes), for example, to produce the mean as follow:*

```{r}
brca_rna_dup <- read.table("/Users/mylinh/Documents/published_data/tcga/brca/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[ ,c(1,3,4,5)]
colnames(brca_rna_dup) <- c("hugo", "brca.s1", "brca.s2", "brca.s3")
brca_rna_dup$cancer.type <- "BRCA"
brca_rna_dup %>%
  gather(key = sample, value = RPKM, brca.s1, brca.s2, brca.s3) %>%
  dcast(hugo~sample, fun.aggregate = mean, value=RPKM, na.rm=TRUE) %>%
  head(10) %>%
  kable("html") %>% kable_styling()
```


## Just making up the full_dataset  

For the next step, I will have to skip ahead in the tasks a little and use some joining funcitons to compound all these TCGA datasets into one "gapminder-like" dataset.
```{r}
list_datasets <- list(brca_rna_gather, gbm_rna_gather, pcpg_rna_gather, sarc_rna_gather, skcm_rna_gather, coadread_rna_gather, dlbc_rna_gather)
# View(list_genomic_datasets_v3)
full_dataset <- list_datasets %>%
  Reduce(function(x, y) full_join(x, y), .)
```
**Note.** I won't lie, I needed to read a lot in order to figure the chunk of code above: I found how to use the Reduce function [here](https://stackoverflow.com/questions/8091303/simultaneously-merge-multiple-data-frames-in-a-list). Have a read and you will understand how it works :)

## Activity #2 - Make a tibble with one row per year and columns for life expectancy for two or more countries  

I will make a tibble with one row per gene (year) and columns for RPKM values (life expectancy) for two of more cancer samples (countries) in the BRCA group (continent).

```{r}
full_dataset %>%
  filter(cancer.type=="BRCA") %>%
  spread(key=sample, value =RPKM) %>%
  head(10) %>%
  kable("html") %>% kable_styling()
```

## Activity #3 - Tidyr  

Compute some measure of RPKM (lifeExp) (mean? median? min? max?) for all possible combinations of cancer group (continent) and hugo (year). 

```{r}
full_dataset %>%
  group_by(hugo, cancer.type) %>%
  summarize(mean.cancer=signif(mean(RPKM),2), median.cancer = signif(median(RPKM), 2), min.cancer=signif(min(RPKM), 2), max.cancer=signif(max(RPKM), 2)) %>%
  head(10) %>%
  kable("html") %>% kable_styling()
```

Reshape that to have one row per hugo (year) and one variable for each cancer group (continent). 

This sounds like spread() and gather() would be useful here. So let's start by doing this exercise with the mean.cancer variable.
```{r}
d1 <- full_dataset %>%
  group_by(hugo, cancer.type) %>%
  summarize(mean.cancer= signif(mean(RPKM), 2)) %>%
  gather(key=stat.category, value= the.number , mean.cancer) %>%
  spread(key=cancer.type, value=the.number)
d1 %>% head(10) %>% kable("html") %>% kable_styling()
```

**Wow ... that took a long time, so let me reason through the process for one second:**

* I grouped by hugo gene (year) and cancer.type (continent)
* Got my summary stat mean.cancer 
* Used gather() with a key = stat.category and a value = the.number and mean.cancer
- Key = new variable created = stat.category
- Value = column name representing the value = the.number, which is a temporary variable I created to use in the spread() function after
- Names of columns to gather = mean.cancer
* Used spread() with a key = cancer.type and a value=the.number
- Which means that the cancer.type now became columns of their own
- And I indicated the value = the.number, which means the mean.cancer value in this case.

**Is there a plot that is easier to make with the data in this shape versus the usual form? If so (or you think so), try it! Reflect.**

Well, I am not sure actually. There might be one: plotting the hugo (year) summary stats according to the cancer.type (continent) will be easier I think. 

For example, I can easily plot the breast cancer (BRCA) mean.cancer values and the difference between the hugo gene (year). I know it is almost impossible to read the gene name, but I had to make them small so they wouldn't overlap on each other.
```{r}
p1 <- d1 %>%
  ggplot(aes(x=hugo, y= BRCA), na.rm = TRUE)
p1 + geom_point() + 
   theme(text = element_text(size=8), axis.text.x = element_text(angle=45, hjust=1))
```

And now, we can extend it to more summary statistics:
```{r}
d2 <- full_dataset %>%
  group_by(hugo, cancer.type) %>%
  summarize(mean.cancer= signif(mean(RPKM), 2), median.cancer = signif(median(RPKM), 2), min.cancer=signif(min(RPKM), 2), max.cancer=signif(max(RPKM), 2)) %>%
  gather(key=stat.category, value= the.number , mean.cancer, median.cancer, min.cancer, max.cancer) %>%
  spread(key=cancer.type, value=the.number)
d2 %>% head(10) %>% kable("html") %>% kable_styling()
```

## Activity #3 - Reshape  

Actually, I think reshape is more appropriate to manipulate the data and make plots here. 
```{r}
d_resh <- d2 %>%
  melt() %>%
  dcast(variable + hugo ~stat.category , sum)
d_resh %>% head(16) %>% kable("html") %>% kable_styling()
```

**Is there a plot that is easier to make with the data in this shape versus the usual form? If so (or you think so), try it! Reflect.**

Let's group by hugo genes and then plot the mean.cancer expression.the for each cancer.type (variable).
```{r}
p_resh <- d_resh %>%
  arrange(hugo) %>%
  head(50) %>%
  group_by(variable) %>%
  ggplot(aes(x=hugo, y=log(mean.cancer)))
p_resh + geom_point(aes(colour=variable), alpha=0.8, size=10, shape=10) + 
   theme(text = element_text(size=18), axis.text.x = element_text(angle=45, hjust=1))
```
Observation: We can see which cancer type (variable) has the highest or lowest mean.cancer gene expression for individual genes.

Resource on reshape [here](http://www.dummies.com/programming/r/how-to-cast-data-to-wide-format-in-r/)

I think I still prefer starting from the full_dataset to make plots with summary values.
```{r}
full_dataset %>%
  group_by(cancer.type, hugo) %>%
  ggplot(aes(x=hugo, y=log(RPKM), colour=cancer.type)) +
  stat_summary(fun.y = mean, fun.ymin=min, fun.ymax = max) +
  theme(text = element_text(size=8), axis.text.x = element_text(angle=45, hjust=1))
```
Note. I know there is a lof of superposition here, we can always facet and remove the x-labels for a better visual:
```{r}
full_dataset %>%
  group_by(cancer.type, hugo) %>%
  ggplot(aes(x=hugo, y=log(RPKM), colour=cancer.type)) +
  stat_summary(fun.y = mean, fun.ymin=min, fun.ymax = max) +
   theme(text = element_text(size=12), axis.title.x=element_blank(), axis.text.x = element_blank(), axis.ticks.x=element_blank()) +
  facet_wrap(~cancer.type)
```

Or the other way around: one row per cancer group (continent) and one variable hugo gene (year). Let's just do all the summary statistics on this one.
```{r}
d3 <- full_dataset %>%
  group_by(cancer.type, hugo) %>%
  summarize(mean.cancer= signif(mean(RPKM), 2), median.cancer = signif(median(RPKM), 2), min.cancer=signif(min(RPKM), 2), max.cancer=signif(max(RPKM), 2)) %>%
  gather(key=stat.category, value= the.number , mean.cancer, median.cancer, min.cancer, max.cancer) %>%
  spread(key=hugo, value=the.number)
d3 %>% head(16) %>%
  kable("html") %>% kable_styling()
```

## Activity #4 - Window functions   

* This cran [dplyr resource](https://cran.r-project.org/web/packages/dplyr/vignettes/window-functions.html) provided a bit more information on these functions.
* This [hadley github vignette](https://github.com/tidyverse/dplyr/blob/master/vignettes/window-functions.Rmd)
* This [blog](https://blog.exploratory.io/filter-data-with-aggregate-and-window-functions-88e3b2353c00) was extremely helpful as well. 

Alghouth window functions are a variation on aggregation functions, as seen in [class 8](http://stat545.com/cm008_dplyr-single-table.html) of STAT545,  they take a vector of length n and n values, which differentiate them from the aggregate functions. Window functions are used in concert with mutate() and filter() functions. There are 5 broad categories of window functions:

1. Ranking and ordering: row_number(), min_rank(), dense_rank(), cume_dist(), percent_rank(), and ntile()
2. Offset: Offsets lead() and lag()  
3. Cumulative aggregates: cumsum(), cummin(), cummax() (from base R), and cumall(), cumany(), and cummean() (from dplyr)  
4. Rolling aggregates (require other packages, e.g. RccpRoll, not covered in class)
5. Recycled aggregate (SQL applications, not covered in class)

I will form a tibble: 2 RPKM values per hugo gene, giving the sample with both the lowest and highest RPKM. I am having a really hard time to imagine some applications of window functions for this type of data. I tried the function suggested on the [stat545 website](http://stat545.com/block010_dplyr-end-single-table.html#window-functions), but since the is a lot values RPKM zero, it is not very informative:
```{r}
d4 <- full_dataset %>%
  select(hugo, sample, RPKM) %>%
  group_by(hugo) %>%
  filter(min_rank(desc(RPKM)) < 2 | min_rank(RPKM) < 2) %>%
  arrange(hugo)
d4 %>% head(10) %>%
  kable("html") %>% kable_styling()
```

*RANKING*

These window functions will be most useful to filter the data in my case. In the example below, I want to know what are the 2 highest RPKM values for each cancer type and which genes these are associated with. Therefore, I group_by(cancer.type) and then I filter with min_rank to keep only the 2 highest values. You can see that each cancer.type (e.g. BRCA) only has 2 values in the table, corresponding to rank 1 and 2 of this group of cancers.

```{r}
full_dataset %>%
  group_by(cancer.type) %>%
  arrange(RPKM, hugo) %>%
  filter(min_rank(desc(RPKM)) <= 2) %>%
  kable("html") %>% kable_styling()
```
Note. I tried to understand this R-manual article on [rank and ties.methods](https://stat.ethz.ch/R-manual/R-devel/library/base/html/rank.html), but I can't figure out how to use data from a matrix with this function.

*WINDOW - MUTATE*

Let's calculate the z score of each hugo gene for each sample compared to the cancer.type, and I arranged them to see the order of the highest z-scores for each gene in a cancer_group:
```{r}
full_dataset %>%
  group_by(cancer.type) %>%
  mutate(sample, RPKM_z = (RPKM - mean(RPKM))/sd(RPKM)) %>%
  arrange(cancer.type, desc(RPKM_z)) %>%
  head(10) %>%
  kable("html") %>% kable_styling()
```

Since I do not have a time variable, I will not illustrate the lag() or lead() functions. If I ever have time series sequencing data, I will apply these functions.

## Activity #5 - Make a data manipulation sampler  

The example given of previous TA Andrew MacDonald can be found [here](https://gist.github.com/aammd/11386424).

It would make more sense for a cheatsheet to be separate from the homework (and not embedded in it), so please click [HERE](https://github.com/mylinhthibodeau/STAT545-HW-thibodeau-mylinh/blob/master/stat545-hw4-thibodeau-mylinh/hw04-data-manipulation-cheatsheet.md) to see my Activity #5. 


***
***

# Join, merge, look up

## Activity #1 - Create two complementary data frames and use join functions  

### DATASET 1  

I will create a smaller version of the first data frame I had for this exercise (because full_dataset is too large). 

The first dataset will contain the list of all genes and RPKM expression values for only one breast cancer tumour sample (brca.s1).
```{r}
brca_rna_v2 <- read.table("/Users/mylinh/Documents/published_data/tcga/brca/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, strip.white = TRUE)[ ,c(1,3)]
colnames(brca_rna_v2) <- c("hugo", "brca.s1")
brca_rna_v2 <- brca_rna_v2[!duplicated(brca_rna_v2$hugo), ]
```

### DATASET 2  

The second dataset will be the The Cancer Gene Census (CGC) from the COSMIC (Catalogue of Somatic Mutations In Cancer) database. The Cancer Gene Census is publically available [here](http://cancer.sanger.ac.uk/census). 

Original census and analysis publication:  
Futreal PA, Coin L, Marshall M, Down T, Hubbard T, Wooster R, Rahman N,
Stratton MR. A census of human cancer genes. Nat Rev Cancer. 2004
Mar;4(3):177-83. Review. PubMed PMID: 14993899; PubMed Central PMCID: PMC2665285.

```{r}
cosmic_census <- read.table("scratch-space/Cosmic_Census.tsv", sep = "\t", header=TRUE, strip.white = TRUE)
summary(cosmic_census) %>% kable("html") %>% kable_styling()
dim(cosmic_census)
colnames(cosmic_census)
#sapply(cosmic_census, class)  %>% kable("html") %>% kable_styling()  
# View(cosmic_census)
```

The Cancer Gene Census (cosmic_census) provides annotations on 567 genes that have been linked to cancer molecular pathophysiology. 

## Test some join functions of dplyr

Please note that the Gene.Symbol column of cosmic_census correspond to the hugo column of brca_rna_v2, hence why I account for it when joining by below. We will be joining the information of 2 datasets:

* brca_rna_v2: contains the hugo genes and the RPKM (gene expression) values of one breast cancer tumour sample
* cosmic_census: contains a list of Gene.Symbol genes involved in cancer,  and several annotations: type of tumours in which it plays a role (Tumour.Types.Somatic.), type of somatic mutations that can lead to cancer (Mutation.Types), etc.
 
### MUTATING JOIN

#### left_join()

*Objective/process:* With left_join(), I start with the cosmic_census, and then I append the brca_rna_v2 data based on a column of matching genes. 

brca_rna_v2$hugo genes are compared against cosmic_census$Gene.Symbol genes, when a match is found, the data from the matching corresponding brca_rna_v2 row is appended to cosmic_census. For genes only in cosmic_census, the new columns are populated with "NA".  

```{r}
t1 <- left_join(cosmic_census, brca_rna_v2, by = c("Gene.Symbol"="hugo")) %>%
  select(Gene.Symbol, Tumour.Types.Somatic., Role.in.Cancer, brca.s1) 
t1 %>% head(10) %>% kable(format = "markdown", align=NULL)
dim(t1)
```
Note. I had error messages when trying to pipe the table into kable function, and I found that kable can introduce space or newline, and that I could solve it by using aling=NULL as explained [here](https://github.com/yihui/knitr/issues/699).

*Observations*

* There is not rna expression data for the AFF1
* AMER1 is involved in Wilms tumour pathogenesis, and in our breast cancer sample, AMER1 expression was around 439 RPKM.

#### right_join()

*Objective/process:* With right_join(), it's the reverse of left_join(): I start with brca_rna_v2 and match cosmic_census to brca_rna_v2. 

```{r}
t2 <- right_join(cosmic_census, brca_rna_v2, by = c("Gene.Symbol"="hugo")) %>% select(Gene.Symbol, Tumour.Types.Somatic., Role.in.Cancer, brca.s1) 
t2 %>% head(10) %>% kable(format = "markdown", align=NULL)
dim(t2)
```

*Observations*

* Since the maximum of matches is 567 (number of rows in cosmic_census) out of 20500 (number of rows in brca_rna_v2), it is not surprising that the Tumour.Types.Somatic. and Role.in.Cancer columns are populations with NA when we only look at 10 rows.
* Since right_join(cosmic_census, brca_rna_v2) is equivalent to left_join(brca_rna_v2, cosmic_census), I personally feel it is less confusing to stick with left_join() and swap the order of the datasets inside the function.

#### inner_join()

*Objective/process:* With inner_join(), I only return the rows that match in both cosmic_census and brca_rna_v2.  

```{r}
t3 <- inner_join(cosmic_census, brca_rna_v2, by = c("Gene.Symbol"="hugo")) %>% 
select(Gene.Symbol, Tumour.Types.Somatic., Role.in.Cancer, brca.s1)
t3  %>% head(10) %>% kable(format = "markdown", align=NULL) 
dim(t3)
```
*Observations*

* There is 419 genes that are present in both datasets.
* There is no "NA" value in this table.

#### full_join()

*Objective/process:* With full_join(), I append all the information of brca_rna_v2 to cosmic_census.

```{r}
t4 <-  full_join(cosmic_census, brca_rna_v2, by = c("Gene.Symbol"="hugo")) %>% select(Gene.Symbol, Tumour.Types.Somatic., Role.in.Cancer, brca.s1) 
t4 %>% head(10) %>% kable(format = "markdown", align=NULL)
dim(t4)
```

*Observations*

* This function creates the largest dataset (20648 rows) as it keeps all the information.
* Weirdly enough, there is one entry in brca_rna_v2 for which there is expression data, but no gene in the hugo column, and this mysterious NA gene has an expression level of:

```{r}
brca_rna_v2 %>%
  filter(is.na(hugo))
```


## FILTERING JOIN

#### semi_join()

*Objective/process:* With semi_join(), I get all the rows from cosmic_census for which there is a match in brca_rna_v2. 

```{r}
t5 <- cosmic_census %>%
  select(Gene.Symbol, Tumour.Types.Somatic., Role.in.Cancer) %>%
  semi_join(brca_rna_v2, by = c("Gene.Symbol"="hugo"))

dim(t5)
t5 %>% head(10) %>% kable(format = "markdown", align=NULL)
```
*Observations*

* It does not append the data from brca_rna_v2 because semi_join() is a filtering function. 
* Even thought the gene expression data is not appended, we know that the genes listed in t5 are also present in brca_rna_v2 because semi_join() keeps only the data of cosmic_census if a gene is present in both datasets.

#### anti_join()

*Objective/process:* The anti_join() is the mirror function of semi_join(). It will only keep the rows of cosmic_census if Gene.Symbol does NOT match brca_rna_v2$hugo. 

```{r}
t6 <- cosmic_census %>%
  select(Gene.Symbol, Tumour.Types.Somatic., Role.in.Cancer) %>%
  anti_join(brca_rna_v2, by = c("Gene.Symbol"="hugo"))

dim(t6)
t6 %>% head(10) %>% kable(format = "markdown", align=NULL)
```

*Observation:*

* I can hardly imagine a role for this function with my current data, but that is because I picked my two datasets (cosmic_census and brca_rna_v2) thinking about mutating and appending data, not about filtering out data, and therefore, my datasets have complementary information. If I had two redundant datasets, the filtering functions would be more applicable.

## Activity #2 - Create your own cheatsheet of dplyr join functions

Please click [HERE](https://github.com/mylinhthibodeau/STAT545-HW-thibodeau-mylinh/blob/master/stat545-hw4-thibodeau-mylinh/hw04-dplyr-join-cheatsheet.md) to see a minimalist dplyr joining functions cheatsheet.

***
