---
title: "stat545-hw04-thibodeau-mylinh"
author: "My Linh Thibodeau"
date: '2017-10-07'
output: github_document
---

```{r}
suppressPackageStartupMessages(library(tidyverse))
knitr::opts_chunk$set(fig.width=12, fig.height=9)
library(knitr)
library(kableExtra)
options(knitr.table.format = "html")
#install.packages("scales")
library(scales)
#install.packages("tidygenomics")
library(tidygenomics)
```

# Genomic dataset - A few clarifications

Vincenzo Coia has approved my request to use published genomic data for the next assignments, therefore, I want to provide a few clarifications:

* I have tried to introduce some basic explanations about the genomic dataset, but obviously, this is not a genetics course and my objective is to explore and learn how to use R and its packages, not to teach complex notions of cancer genomic analysis. Therefore, I don't expect people to understand what the data and plots represent if they haven't studied in related fields.  

## SOURCES OF DATA: The Cancer Genome Atlas (TCGA) and ClinVar 

After trying to complete this homework with the genomic data previously used in [homework 3](https://github.com/mylinhthibodeau/STAT545-HW-thibodeau-mylinh/tree/master/stat545-hw3-thibodeau-mylinh), I realized that it was impossible for me to do some of the exercises because I didn't have the right "data.frame" format for it. 

*The Cancer Genome Atlas (TCGA)*  
The results shown here are in whole or part based upon data generated by the TCGA Research Network: http://cancergenome.nih.gov/. 

Genomic datasets are available through the cBioportal [here](http://www.cbioportal.org/data_sets.jsp)

*ClinVar*
The results shown here are in whole or part based upon the data generated by the NCBI ClinVar data portal: https://www.ncbi.nlm.nih.gov/clinvar/

The ClinVar genomic variant dataset is publicly available [here](ftp://ftp.ncbi.nlm.nih.gov/pub/clinvar/tab_delimited/). If you would like more information on the type of files available, please read this [primer](https://www.ncbi.nlm.nih.gov/clinvar/docs/ftp_primer/) on the topic.

# Setting up the data

## Getting the data ready

Let's select some RNAseq (gene expression) cancers datasets from TCGA:

* brca: breast cancer
* gbm: glioblastoma
* pcpg: pheochromocytome-paraganglioma
* sarc: sarcoma
* skcm: skin cutaneous melanoma
* coadread: colorectal adenocarcinoma
* dlbc: diffuse large B-cell lymphoma

I will only select 50 genes (nrows = 100) for each dataset, because there are way to many genes (18000-20000) to keep them all, and also, we will only select 3 samples per cancer type ([ ,c(1,3,4,5)]):
```{r}
brca_rna <- read.table("/Users/mylinh/Documents/published_data/tcga/brca/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[ ,c(1,3,4,5)]
colnames(brca_rna) <- c("hugo", "brca.s1", "brca.s2", "brca.s3")
brca_rna <- brca_rna[!duplicated(brca_rna$hugo), ]
brca_rna$cancer.type <- "BRCA"
#View(brca_rna)

gbm_rna <- read.table("/Users/mylinh/Documents/published_data/tcga/gbm/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[, c(1,3,4,5)]
colnames(gbm_rna) <- c("hugo", "gbm.s1", "gbm.s2", "gbm.s3")
gbm_rna <- gbm_rna[!duplicated(gbm_rna$hugo), ]
gbm_rna$cancer.type <- "GBM"
#View(gbm_rna)

pcpg_rna <- read.table("/Users/mylinh/Documents/published_data/tcga/pcpg/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[, c(1,3,4,5)]
colnames(pcpg_rna) <- c("hugo", "pcpg.s1", "pcpg.s2", "pcpg.s3")
pcpg_rna <- pcpg_rna[!duplicated(pcpg_rna$hugo), ]
pcpg_rna$cancer.type <- "PCPG"
#View(pcpg_rna)

sarc_rna <- read.table("/Users/mylinh/Documents/published_data/tcga/sarc/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[, c(1,3,4,5)]
colnames(sarc_rna) <- c("hugo", "sarc.s1", "sarc.s2", "sarc.s3")
sarc_rna <- sarc_rna[!duplicated(sarc_rna$hugo), ]
sarc_rna$cancer.type <- "SARC"
#View(sarc_rna)

skcm_rna <- read.table("/Users/mylinh/Documents/published_data/tcga/skcm/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[, c(1,3,4,5)]
colnames(skcm_rna) <- c("hugo", "skcm.s1", "skcm.s2", "skcm.s3")
skcm_rna <- skcm_rna[!duplicated(skcm_rna$hugo), ]
skcm_rna$cancer.type <- "SKCM"
#View(skcm_rna)

coadread_rna <- read.table("/Users/mylinh/Documents/published_data/tcga/coadread/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[, c(1,3,4,5)]
colnames(coadread_rna) <- c("hugo", "coadread.s1", "coadread.s2", "coadread.s3")
coadread_rna <- coadread_rna[!duplicated(coadread_rna$hugo), ]
coadread_rna$cancer.type <- "COADREAD"
#View(coadread_rna)

dlbc_rna <- read.table("/Users/mylinh/Documents/published_data/tcga/dlbc/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE, nrows =100)[, c(1,3,4,5)]
colnames(dlbc_rna) <- c("hugo", "dlbc.s1", "dlbc.s2", "dlbc.s3")
dlbc_rna <- dlbc_rna[!duplicated(dlbc_rna$hugo), ]
dlbc_rna$cancer.type <- "DLBC"
#View(dlbc_rna)
```
Note1. I populated one additional column per dataset with the cancer.type as this will represent my "gapminder$continent" value later on. I tried the technique explained on [computer world here](https://www.computerworld.com/article/2486415/business-intelligence/business-intelligence-4-data-wrangling-tasks-in-r-for-advanced-beginners.html), and although it didn't work out, it gave me the idea of creating a new column "cancer.type" with a single value for the specific cancer.
Note2. I found a way of selecting specific columns in read.table with [this stackoverflow dicussion](https://stackoverflow.com/questions/5788117/only-read-limited-number-of-columns) and [this stackexchange discussion](https://stats.stackexchange.com/questions/16796/reading-only-two-out-of-three-columns-with-read-csv).
Note3. After experiencing issues later on in this homework, I had to remove the hugo genes that had 2 or more values for the same cancer sample. I needed to have only one gene-sample key for the spread() function to workout. I found the information about how to remove duplicate [here](https://stackoverflow.com/questions/13279582/select-only-the-first-rows-for-each-unique-value-of-a-column-in-r)

# General data reshaping and relationship to aggregation

## Activity #1 - Make your own cheetsheet

*Make you own cheatsheet similar to Tyler Rinkerâ€™s [minimal guide to tidyr](https://github.com/trinker/tidyr_in_a_nutshell).*

I also like this [Data Wrangling with dplyr and tidyr cheat sheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf).

I found a few tutorials that I liked as well:

* University of Virginia: [A tidyr Tutorial](http://data.library.virginia.edu/a-tidyr-tutorial/)
* RPubs of RStudio: [Data Processing with dplyr & tidyr](https://rpubs.com/bradleyboehmke/data_wrangling) by Brad Boehmke
* Tidyverse website: [tidyr article](http://tidyr.tidyverse.org/)

### GATHER: From horizontal (wide) to vertical (longer)

According the the Help of RStudio, the gather() function is a way to take columns that are not variables and collapse multiple columns to key-value pairs. 

For my type of data, I think gather() will be useful when I realize that a group of columns actually represent the same variable and therefore, they should be "stacked on top of each other" () rather than in adjacent columns. As Hadley Wickham said in his [Introducing tidyr blog](https://blog.rstudio.com/2014/07/22/introducing-tidyr/),the most important for tidy data is that each column is a variable and each row is an observation.

Let's take a look at the brca_rna data:
```{r}
brca_rna %>%
  head(15) %>%
  kable("html") %>% kable_styling()
```

The TCGA RNAseq datasets are perfect for this exercise, because the columns in each dataset represent a different sample, and therefore, they are actually different obversations. I will start by making new "gathered" data.frame.
```{r}
brca_rna_gather <- brca_rna %>%
  gather(key = sample, value = RPKM, brca.s1, brca.s2, brca.s3)
#View(brca_rna_gather)
gbm_rna_gather <- gbm_rna %>%
  gather(key=sample, value = RPKM, gbm.s1, gbm.s2, gbm.s3)
pcpg_rna_gather <- pcpg_rna %>%
  gather(key = sample, value = RPKM, pcpg.s1, pcpg.s2, pcpg.s3)
sarc_rna_gather <- sarc_rna %>%
  gather(key=sample, value = RPKM, sarc.s1, sarc.s2, sarc.s3)
skcm_rna_gather <- skcm_rna %>%
  gather(key = sample, value = RPKM, skcm.s1, skcm.s2, skcm.s3)
coadread_rna_gather <- coadread_rna %>%
  gather(key = sample, value = RPKM, coadread.s1, coadread.s2, coadread.s3)
dlbc_rna_gather <- dlbc_rna %>%
  gather(key =sample, value = RPKM, dlbc.s1, dlbc.s2, dlbc.s3)
```

And now, if we take the same brca data, but the after using the gather() function:
```{r}
brca_rna_gather %>%
  head(15) %>%
  kable("html") %>% kable_styling()
```

### SPREAD: From vertical (longer) to horizontal (wide)

In order to revert back to the original format of the data, I can use the same key:value pairing in the spread() function. For example, the following code's output is the original data format since gather() and spread() are mirror functions from each other.

```{r}
brca_rna %>%
  gather(key = sample, value = RPKM, brca.s1, brca.s2, brca.s3) %>%
  spread(key=sample, value=RPKM) %>%
  head(15) %>%
  kable("html") %>% kable_styling()
```
*So it turns out that the spread() function does not like the fact that some gene names are duplicated for the sample sample initially, as it returned the message "Error: Duplicate identifiers for rows (2, 3), (52, 53), (102, 103)". So I have decided to change apply some extra functions to filter the duplicate when I read the TCGA cancer datasets files at the beginning of the homework.*

## Join, merge, look up - Just making up the full_dataset 

For the next step, I will have to skip ahead in the tasks a little and use some joining funcitons to compound all these TCGA datasets into one "gapminder-like" dataset.
```{r}
list_datasets <- list(brca_rna_gather, gbm_rna_gather, pcpg_rna_gather, sarc_rna_gather, skcm_rna_gather, coadread_rna_gather, dlbc_rna_gather)
# View(list_genomic_datasets_v3)
full_dataset <- list_datasets %>%
  Reduce(function(x, y) full_join(x, y), .)
```
Note. I won't lie, I needed to read a lot in order to figure the chunk of code above:

* 

## Activity #2 - Make a tibble with one row per year and columns for life expectancy for two or more countries.

I will make a tibble with one row per gene (year) and columns for RPKM values (life expectancy) for two of more cancer samples (countries) in the BRCA group (continent).

```{r}
full_dataset %>%
  filter(cancer.type=="BRCA") %>%
  spread(key=sample, value =RPKM) %>%
  head(15) %>%
  kable("html") %>% kable_styling()
```


## Activity #3

Compute some measure of RPKM (lifeExp) (mean? median? min? max?) for all possible combinations of cancer group (continent) and hugo (year). 

```{r}
full_dataset %>%
  group_by(hugo, cancer.type) %>%
  summarize(mean.cancer=signif(mean(RPKM),2), median.cancer = signif(median(RPKM), 2), min.cancer=signif(min(RPKM), 2), max.cancer=signif(max(RPKM), 2)) %>%
  head(15) %>%
  kable("html") %>% kable_styling()
```

Reshape that to have one row per hugo (year) and one variable for each cancer group (continent). 

This sounds like spread() and gather() would be useful here. So let's start by doing this exercise with the mean.cancer variable.
```{r}
d1 <- full_dataset %>%
  group_by(hugo, cancer.type) %>%
  summarize(mean.cancer= signif(mean(RPKM), 2)) %>%
  gather(key=stat.category, value= the.number , mean.cancer) %>%
  spread(key=cancer.type, value=the.number)
d1 %>% head(15) %>% kable("html") %>% kable_styling()
```

*Wow ... that took a long time, so let me reason through the process for one second:*

* I grouped by hugo gene (year) and cancer.type (continent)
* Got my summary stat mean.cancer 
* Used gather() with a key = stat.category and a value = the.number and mean.cancer
- Key = new variable created = stat.category
- Value = column name representing the value = the.number, which is a temporary variable I created to use in the spread() function after
- Names of columns to gather = mean.cancer
* Used spread() with a key = cancer.type and a value=the.number
- Which means that the cancer.type now became columns of their own
- And I indicated the value = the.number, which means the mean.cancer value in this case.

*Is there a plot that is easier to make with the data in this shape versus the usual form? If so (or you think so), try it! Reflect.*

Well, I am not sure actually. There might be one: plotting the hugo (year) summary stats according to the cancer.type (continent) will be easier I think. 

For example, I can easily plot the breast cancer (BRCA) mean.cancer values and the difference between the hugo gene (year). I know it is almost impossible to read the gene name, but I had to make them small so they wouldn't overlap on each other.
```{r}
p1 <- d1 %>%
  ggplot(aes(x=hugo, y= BRCA), na.rm = TRUE)
p1 + geom_point() + 
   theme(text = element_text(size=8), axis.text.x = element_text(angle=45, hjust=1))
```

And now, we can extend it to more summary statistics:
```{r}
d2 <- full_dataset %>%
  group_by(hugo, cancer.type) %>%
  summarize(mean.cancer= signif(mean(RPKM), 2), median.cancer = signif(median(RPKM), 2), min.cancer=signif(min(RPKM), 2), max.cancer=signif(max(RPKM), 2)) %>%
  gather(key=stat.category, value= the.number , mean.cancer, median.cancer, min.cancer, max.cancer) %>%
  spread(key=cancer.type, value=the.number)
d2 %>% head(15) %>% kable("html") %>% kable_styling()
```

I think I still prefer starting from the full_dataset to make plots with summary values.
```{r}
full_dataset %>%
  group_by(cancer.type, hugo) %>%
  ggplot(aes(x=hugo, y=log(RPKM), colour=cancer.type)) +
  stat_summary(fun.y = mean, fun.ymin=min, fun.ymax = max) +
  theme(text = element_text(size=8), axis.text.x = element_text(angle=45, hjust=1))
```
Note. I know there is a lof of superposition here, we can always facet and remove the x-labels for a better visual:
```{r}
full_dataset %>%
  group_by(cancer.type, hugo) %>%
  ggplot(aes(x=hugo, y=log(RPKM), colour=cancer.type)) +
  stat_summary(fun.y = mean, fun.ymin=min, fun.ymax = max) +
   theme(text = element_text(size=12), axis.title.x=element_blank(), axis.text.x = element_blank(), axis.ticks.x=element_blank()) +
  facet_wrap(~cancer.type)
```


Or the other way around: one row per cancer group (continent) and one variable hugo gene (year). Let's just do all the summary statistics on this one.
```{r}
full_dataset %>%
  group_by(cancer.type, hugo) %>%
  summarize(mean.cancer= signif(mean(RPKM), 2), median.cancer = signif(median(RPKM), 2), min.cancer=signif(min(RPKM), 2), max.cancer=signif(max(RPKM), 2)) %>%
  gather(key=stat.category, value= the.number , mean.cancer, median.cancer, min.cancer, max.cancer) %>%
  spread(key=hugo, value=the.number) %>%
  head(15) %>%
  kable("html") %>% kable_styling()
```

Is there a plot that is easier to make with the data in this shape versus the usual form? If so (or you think so), try it! Reflect.

## Activity #4 - Window functions
* This cran [dplyr resource](https://cran.r-project.org/web/packages/dplyr/vignettes/window-functions.html) provided a bit more information on these functions.
* This [hadley github vignette](https://github.com/tidyverse/dplyr/blob/master/vignettes/window-functions.Rmd)
* This [blog](https://blog.exploratory.io/filter-data-with-aggregate-and-window-functions-88e3b2353c00) was extremely helpful as well. 

Alghouth window functions are a variation on aggregation functions, as seen in [class 8](http://stat545.com/cm008_dplyr-single-table.html) of STAT545,  they take a vector of length n and n values, which differentiate them from the aggregate functions. Window functions are used in concert with mutate() and filter() functions. There are 5 broad categories of window functions:

1. Ranking and ordering: row_number(), min_rank(), dense_rank(), cume_dist(), percent_rank(), and ntile()
2. Offset: Offsets lead() and lag()  
3. Cumulative aggregates: cumsum(), cummin(), cummax() (from base R), and cumall(), cumany(), and cummean() (from dplyr)  
4. Rolling aggregates (require other packages, e.g. RccpRoll, not covered in class)
5. Recycled aggregate (SQL applications, not covered in class)

I will form a tibble: 2 RPKM values per hugo gene, giving the sample with both the lowest and highest RPKM. I am having a really hard time to imagine some applications of window functions for this type of data. I tried the function suggested on the [stat545 website](http://stat545.com/block010_dplyr-end-single-table.html#window-functions), but since the is a lot values RPKM zero, it is not very informative:
```{r}
d3 <- full_dataset %>%
  select(hugo, sample, RPKM) %>%
  group_by(hugo) %>%
  filter(min_rank(desc(RPKM)) < 2 | min_rank(RPKM) < 2) %>%
  arrange(hugo)
d3 %>% head(15) %>%
  kable("html") %>% kable_styling()
```

*RANKING*

These window functions will be most useful to filter the data in my case. In the example below, I want to know what are the 2 highest RPKM values for each cancer type and which genes these are associated with. Therefore, I group_by(cancer.type) and then I filter with min_rank to keep only the 2 highest values. You can see that each cancer.type (e.g. BRCA) only has 2 values in the table, corresponding to rank 1 and 2 of this group of cancers.

```{r}
full_dataset %>%
  group_by(cancer.type) %>%
  arrange(RPKM, hugo) %>%
  filter(min_rank(desc(RPKM)) <= 2) %>%
  kable("html") %>% kable_styling()
```
Note. I tried to understand this R-manual article on [rank and ties.methods](https://stat.ethz.ch/R-manual/R-devel/library/base/html/rank.html), but I can't figure out how to use data from a matrix with this function.

*WINDOW - MUTATE*

Let's calculate the z score of each hugo gene for each sample compared to the cancer.type, and I arranged them to see the order of the highest z-scores for each gene in a cancer_group:
```{r}
full_dataset %>%
  group_by(cancer.type) %>%
  mutate(sample, RPKM_z = (RPKM - mean(RPKM))/sd(RPKM)) %>%
  arrange(cancer.type, desc(RPKM_z)) %>%
  head(15) %>%
  kable("html") %>% kable_styling()
```

Since I do not have a time variable, I will not illustrate the lag() or lead() functions. If I ever have time series sequencing data, I will apply these functions.

## Activity #5 - Make a data manipulation sampler

The example given of previous TA Andrew MacDonald can be found [here](https://gist.github.com/aammd/11386424).

It would make more sense for a cheatsheet to be separate from the homework (and not embedded in it), so please click [HERE]() to see my Activity #5. 


***
***

# Join, merge, look up

## Activity #1 - Create a second data frame

### DATASET 1

I will create a smaller version of the first data frame I had for this exercise: this one will contain the list of all genes and RPKM expression values for only one breast cancer tumour sequenced. 
```{r}
brca_rna_v2 <- read.table("/Users/mylinh/Documents/published_data/tcga/brca/tcga/data_RNA_Seq_v2_expression_median.txt", header = TRUE)[ ,c(1,3)]
colnames(brca_rna_v2) <- c("hugo", "brca.s1")
brca_rna_v2 <- brca_rna_v2[!duplicated(brca_rna_v2$hugo), ]
```

### DATASET 2

The second dataset will be the The Cancer Gene Census (CGC) from the COSMIC (Catalogue of Somatic Mutations In Cancer) database. The CGC is publically available [here](http://cancer.sanger.ac.uk/census). 

Original census and analysis publication:  
Futreal PA, Coin L, Marshall M, Down T, Hubbard T, Wooster R, Rahman N,
Stratton MR. A census of human cancer genes. Nat Rev Cancer. 2004
Mar;4(3):177-83. Review. PubMed PMID: 14993899; PubMed Central PMCID: PMC2665285.

```{r}
cosmic_census <- read.table("Cosmic_Census.tsv", sep = "\t", header=TRUE)
summary(cosmic_census) %>% kable("html") %>% kable_styling()
#sapply(cosmic_census, class)  %>% kable("html") %>% kable_styling()  
# View(cosmic_census)
```


## Test some join functions of dplyr

### MUTATING JOIN

#### left_join()

```{r}
t1 <- left_join(cosmic_census, brca_rna_v2, by = c("Gene.Symbol"="hugo")) %>%
  select(Gene.Symbol, Tumour.Types.Somatic., Role.in.Cancer, brca.s1) 
t1 %>% head(15) %>% kable(format = "markdown", align=NULL)
```
Note. I had error messages when trying to pipe the table into kable function, and I found that kable can introduce space or newline, and that I could solve it by using aling=NULL as explained [here](https://github.com/yihui/knitr/issues/699).

#### right_join()

```{r}
t2 <- right_join(cosmic_census, brca_rna_v2, by = c("Gene.Symbol"="hugo"))
t2 %>% select(Gene.Symbol, Tumour.Types.Somatic., Role.in.Cancer, brca.s1) %>% head(15) %>% kable(format = "markdown", align=NULL)
```

#### inner_join()

```{r}
t3 <- inner_join(cosmic_census, brca_rna_v2, by = c("Gene.Symbol"="hugo"))
t3 %>% select(Gene.Symbol, Tumour.Types.Somatic., Role.in.Cancer, brca.s1) %>% head(15) %>% kable(format = "markdown", align=NULL) 
```

#### full_join()

```{r}
t4 <-  full_join(cosmic_census, brca_rna_v2, by = c("Gene.Symbol"="hugo"))
t4 %>% select(Gene.Symbol, Tumour.Types.Somatic., Role.in.Cancer, brca.s1) %>% head(15) %>% kable(format = "markdown", align=NULL)
```

## FILTERING JOIN

#### semi_join()

```{r}
t5 <- semi_join(cosmic_census, brca_rna_v2, by = c("Gene.Symbol"="hugo"))
t5 %>% head(15) %>% kable(format = "markdown", align=NULL)
```

#### anti_join()

```{r}
t6 <- anti_join(cosmic_census, brca_rna_v2, by = c("Gene.Symbol"="hugo"))
t6 %>% head(15) %>% kable(format = "markdown", align=NULL)
```

## Activity #2 - Create your own cheatsheet

## Optional add-on: merge(), match()

***
